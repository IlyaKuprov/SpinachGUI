#include "../StdAfx.h"
#include "Spinach.h"

//Definitions
#define To_String(aNumber) SpinachGUI::ConvertToString(aNumber, 3, "e3")
#define To_StringG(aNumber) SpinachGUI::ConvertToString(aNumber, 7, "N")
#define InteractionCollection SystemModel->InteractionCollection
#define AtomCollection SystemModel->AtomCollection

/**
*\file Spinach.cpp
*/

#pragma region "Initialization and export"

/**
* @brief Initializator of Spinach class.
* @param aCurrentTitleFile Name of the file to write into.
* @param model The model which the data will be extracted.
*/
System::Void SpinachGUI::Spinach::Spinach_Initialization(Model^% model, String^ aCurrentTitleFile)
{
	SystemModel=model;
	CurrentTitleFile=aCurrentTitleFile;

	PreviewtextBox->AutoSize=true;             //Set autosize of Preview window

	String^ temp=gcnew String("");
	int jj=0;

	//Update  the final strings
	WriteHeader();
	WriteFooter();
}

/**
* @brief Function for writing first lines in a final string for preview and exported file.
*/
System::Void SpinachGUI::Spinach::WriteHeader()
{
	//Empty string for update
	String ^ FileText=gcnew String("");
	String^ temp=gcnew String("");
	String^ temp2=gcnew String("");
	String^ AtomList=gcnew String("");
	String^ AtomLabels=gcnew String("");
	String^ SpinachGUIIndex=gcnew String("");
	
	//Print initial things
	header="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \r\n";
	header+="% This Matlab file is generated by Spinach GUI "+SpinachGUIver+" \r\n";
	header+="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \r\n";
	header+="\r\n";
	header+="function [file_name]() \r\n";
	header+="\r\n";

	//MAgnetic field string
	PreviewtextBox->Text="% Magnet induction \r\n";
	PreviewtextBox->Text+=magnetstring;
	PreviewtextBox->Text+="\r\n";

	//Atoms etc///////////////////////////////////////////////////////////////////////////////////////////////
	//Create Atoms and label matrices
	for each(int i in AtomCollection->Keys) 
	{
		if(((Atom^)AtomCollection[i])->isotope->Element=="e") 
			temp=(i==1? (String ^ )"" : (String ^ )", ")+"\'E\'";
		else
		{
			temp=(i==1? (String ^ )"" : (String ^ )", ")+
				"\'"+((Atom^)AtomCollection[i])->isotope->Mass+
				((Atom^)AtomCollection[i])->isotope->Element+"\'";
		};
		AtomList+=temp;

		//Similarly for writing SpinachGUI Indexes
		temp2 = gcnew String(" ",0, temp->Length);
		temp2=temp2->Insert(1, Convert::ToString(((Atom^)AtomCollection[i])->ID));
		SpinachGUIIndex+=temp2->Remove(temp->Length); //Reduced it to original size

		//If label is not empty or zero size
		AtomLabels+=(((Atom^)AtomCollection[i])->Label!=nullptr && 
			         ((Atom^)AtomCollection[i])->Label!=" " &&
					 ((Atom^)AtomCollection[i])->Label->Length!=0?
			"sys.labels{"+((Atom^)AtomCollection[i])->ID+"}= '"+
		((Atom^)AtomCollection[i])->Label+(String ^ )"';\r\n" 
		:	(String ^ )""); 
	};

	//Print Atoms and Labels
	FileText+="% Isotopes \r\n";
	FileText+="sys.isotopes={"+ AtomList+ "};  \r\n";
	FileText+="\r\n";

	//When a label is present , print it
	if(AtomLabels->Length>0)
	FileText+="% Lables \r\n";
	FileText+= AtomLabels;
	FileText+="\r\n";

	//Write in the preview
	PreviewtextBox->Text+=FileText;
}

/**
* @brief Function for writing last lines in a final string for preview and exported file.
*/
System::Void SpinachGUI::Spinach::WriteFooter()
{
	int A,B;
	String ^ FileText=gcnew String("");
	String ^coord, ^temp;
	double trace=0.0f;
	array<array<String^>^>^ CouplingMatrix=gcnew array<array<String^>^>(AtomCollection->Count);
	array<String^>^ ZeemanMatrix=gcnew array<String^>(AtomCollection->Count);
	//Coordinates etc////////////////////////////////////////////////////////////////////////////////////////

	FileText+="% Coordinates \r\n";
	coord= gcnew String("inter.coordinates={");
	FileText+=coord;
	temp = gcnew String("                   "); //For aligning to the first line
	for each(int i in AtomCollection->Keys)  
	{
		if((((Atom^)AtomCollection[i])->isotope->Element!="e") && (((Atom^)AtomCollection[i])->isotope->Element!="chi"))
			FileText+= (i==1? (String ^ )"[" : (String ^ )";\r\n"+temp+"[")+
			((Atom^)AtomCollection[i])->X+" "+
			((Atom^)AtomCollection[i])->Y+" "+
			((Atom^)AtomCollection[i])->Z+"]";
		else FileText+=(i==1? (String ^ )"[" : (String ^ )";\r\n"+temp+"[ ")+"]";

	};

	FileText+= "};  \r\n";
	FileText+="\r\n";
	FileText+="\r\n";
	FileText+="\r\n";

	//Couplings etc///////////////////////////////////////////////////////////////////////////////////////////
	//Initiate coupling and zeeman matrix
	for (int i=0;i<AtomCollection->Count-1;i++) 
	{
		CouplingMatrix[i]=gcnew array<String^>(AtomCollection->Count);
		ZeemanMatrix[i]="[0 0 0; 0 0 0; 0 0 0]";
		for(int j=0;j<AtomCollection->Count-1;j++)
		{
			CouplingMatrix[i][j]="[0 0 0; 0 0 0; 0 0 0]";
		};
	};	

	FileText+=" \r\n";

	//Write emtrpy matrix for atoms
	FileText+="% Coupling Matrices\r\n";
	FileText+="inter.coupling.matrix=cell("+AtomCollection->Count+");  \r\n";

	//Create coupling and zeeman matrix
	for each(int i in InteractionCollection->Keys) 
	{
		String ^ astring=gcnew String("");

		if(((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::HFC)
			astring="1e6*gauss2mhz([";
		else if(((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::Quadrupolar)
		{
			::Matrix3x3^ matrix3x3=TransformToLab(((Tensor^)InteractionCollection[i]));
			astring="1e6*[";
			//For trace equal to zero after rounding
			trace=Math::Round((Math::Round(1000.0f*matrix3x3[0])+
				Math::Round(1000.0f*matrix3x3[4])+
				Math::Round(1000.0f*matrix3x3[8]))/3.0f)/1000.0f;
		}
		else astring="[";

		//Write chemical bonds minus trace
		if(((Interaction^)InteractionCollection[i])->IntKind!=InteractionKind::CBond)
		{
			::Matrix3x3^ matrix3x3=TransformToLab(((Tensor^)InteractionCollection[i]));
			astring+=
				To_String(Math::Round(matrix3x3[0]*1000.0f)/1000.0f-trace)+" "+
				To_String(matrix3x3[1])+" "+
				To_String(matrix3x3[2])+"; "+
				To_String(matrix3x3[3])+" "+
				To_String(Math::Round(matrix3x3[4]*1000.0f)/1000.0f-trace)+" "+
				To_String(matrix3x3[5])+"; "+
				To_String(matrix3x3[6])+" "+
				To_String(matrix3x3[7])+" "+
				To_String(Math::Round(matrix3x3[8]*1000.0f)/1000.0f-trace)+"]";
		}
		if(((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::HFC)
			astring+=")";

		//Write HFC. Gtensor, Exchange, quadropolar and Zero-Splitting
		if(((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::HFC ||
			((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::Exchange ||
			((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::Quadrupolar ||
			((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::ZFS)
		{
			A=((Tensor^)InteractionCollection[i])->A->ID;
			if(((Tensor^)InteractionCollection[i])->B!=nullptr) B=((Tensor^)InteractionCollection[i])->B->ID;
			
			else B=A;
			FileText+="inter.coupling.matrix{"+A+", "+B+"}="+astring+"; \r\n"; //one-base indexing

		};
	};

	//Write empty Scalar Couplings matrix 
	FileText+=" \r\n";
	FileText+="% Scalar Couplings\r\n";
	FileText+="inter.coupling.scalar=cell("+AtomCollection->Count+");  \r\n";

	//Create coupling and zeeman matrix
	for each(int i in InteractionCollection->Keys)
	{
		String ^ astring=gcnew String("");

		if(((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::Jcoupling)
		{
			astring=To_String(((Tensor^)InteractionCollection[i])->matrix3x3[0]);
			A=((Tensor^)InteractionCollection[i])->A->ID;
			if(((Tensor^)InteractionCollection[i])->B!=nullptr) B=((Tensor^)InteractionCollection[i])->B->ID;
			else B=A;
			FileText+="inter.coupling.scalar{"+A+", "+B+"}="+astring+"; \r\n"; //one-base indexing

		};
	};

	//Write empty susceptibility tensor 
	FileText+=" \r\n";
	FileText+="% Susceptibility tensor\r\n";
	
	//Loop over all interactions for chitensors 
	for each(int i in InteractionCollection->Keys)
	{	
		String ^ astring=gcnew String("");
		::Matrix3x3^ matrix3x3=TransformToLab(((Tensor^)InteractionCollection[i]));
		astring="[";
			
		if(((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::CHITensor)
			astring+=
			To_StringG(matrix3x3[0])+" "+
			To_StringG(matrix3x3[1])+" "+
			To_StringG(matrix3x3[2])+"; "+
			To_StringG(matrix3x3[3])+" "+
			To_StringG(matrix3x3[4])+" "+
			To_StringG(matrix3x3[5])+"; "+
			To_StringG(matrix3x3[6])+" "+
			To_StringG(matrix3x3[7])+" "+
			To_StringG(matrix3x3[8])+"]";
			
		//Write susceptibility tensor 
		if (((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::CHITensor)	
			FileText+="inter.suscept.chi={"+astring+"}; \r\n"; //one-base indexing
	};

	//CHI coordinates etc////////////////////////////////////////////////////////////////////////////////////////	
	FileText+=" \r\n";
	FileText+="% Susceptibility coordinates \r\n";	
	coord= gcnew String("inter.suscept.xyz={");
	FileText+=coord;				
	for each(int i in AtomCollection->Keys)  
	{	
		if(((Atom^)AtomCollection[i])->isotope->Element!="chi") 
			FileText+="";	
		else if (((Atom^)AtomCollection[i])->isotope->Element="chi") 		
			FileText+="["+
			((Atom^)AtomCollection[i])->X+" "+
			((Atom^)AtomCollection[i])->Y+" "+
			((Atom^)AtomCollection[i])->Z+"]";
		else FileText+=(i==1? (String ^ )"[" : (String ^ )";\r\n"+temp+"[ ")+"]";
	
	};
		
	FileText+= "};  \r\n";		

	//Write empty Zeeman matrix 
	FileText+=" \r\n";
	FileText+="% Zeeman Interactions \r\n";
	FileText+="inter.zeeman.matrix=cell(1, "+AtomCollection->Count+");  \r\n";
	System::Collections::Generic::SortedList<int, String^> ^ Zeeman=
		gcnew System::Collections::Generic::SortedList<int, String^>();

	//Loop over all interactions for getnsors, chitensors and shifts
	for each(int i in InteractionCollection->Keys)
	{	
		String ^ astring=gcnew String("");
		::Matrix3x3^ matrix3x3=TransformToLab(((Tensor^)InteractionCollection[i]));
		astring="[";

		if(((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::GTensor)
			astring+=
			To_StringG(matrix3x3[0])+" "+
			To_StringG(matrix3x3[1])+" "+
			To_StringG(matrix3x3[2])+"; "+
			To_StringG(matrix3x3[3])+" "+
			To_StringG(matrix3x3[4])+" "+
			To_StringG(matrix3x3[5])+"; "+
			To_StringG(matrix3x3[6])+" "+
			To_StringG(matrix3x3[7])+" "+
			To_StringG(matrix3x3[8])+"]";			
		else if(((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::Shift)
			astring+=
			To_String(matrix3x3[0])+" "+
			To_String(matrix3x3[1])+" "+
			To_String(matrix3x3[2])+"; "+
			To_String(matrix3x3[3])+" "+
			To_String(matrix3x3[4])+" "+
			To_String(matrix3x3[5])+"; "+
			To_String(matrix3x3[6])+" "+
			To_String(matrix3x3[7])+" "+
			To_String(matrix3x3[8])+"]";

		//Write Chemical Shielding and G-Tensor 
		if(((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::GTensor || 
			((Interaction^)InteractionCollection[i])->IntKind==InteractionKind::Shift)
			Zeeman[((Tensor^)InteractionCollection[i])->A->ID]=
			"inter.zeeman.matrix{"+((Tensor^)InteractionCollection[i])->A->ID+"}="+astring+"; \r\n";//one-base indexing
	};

	//Sorted according to atom ID
	for each(int i in Zeeman->Keys)
		FileText+=Zeeman[i];

	FileText+="\r\n";
	PreviewtextBox->Text+=FileText;

	//Housekeeping Spinach final thingys
	PreviewtextBox->Text+="% Spinach housekeeping \r\n";
	PreviewtextBox->Text+="spin_system=create(sys,inter); \r\n";
	PreviewtextBox->Text+="\r\n";

	//Update strings and Preview window
	final=PreviewtextBox->Text;
	PreviewtextBox->Text=header+final;

	//Change the size of the preview panel
	int maxWidth=0;
	int fontsize=11;
	for(int i=0;i<PreviewtextBox->Lines->Length;i++) 
	{	
		if(PreviewtextBox->Lines[i]->Length>maxWidth) 
			maxWidth=PreviewtextBox->Lines[i]->Length;
	}

	//Set size of preview window
	PreviewtextBox->Width=fontsize*maxWidth;
	PreviewtextBox->Height=PreviewtextBox->Lines->Length*(fontsize+7);
}

/**
* @brief EventHandler for opening the save dialoguebox and  writing the stream to file.
* @param sender The object that fire this event.
* @param e The event arguments for this event handler.
*/
System::Void SpinachGUI::Spinach::Exportbutton_Click(System::Object^  sender, System::EventArgs^  e) 
{	
	//Setting the format and initila filename for the save dialoguebox 
	saveFileDialog->Filter="Spinach File|*.m";
	saveFileDialog->FileName=Path::GetFileNameWithoutExtension(CurrentTitleFile)+".m";

	//Opens the save dialogue box and check if the OK button clicked then save to file
	if (saveFileDialog->ShowDialog() == System::Windows::Forms::DialogResult::OK )
	{	 
		FileStream^ fs=gcnew FileStream(saveFileDialog->FileName,FileMode::Create );

		//SWrites a nice header withe the filename
		header="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \r\n";
		header+="% This Matlab file is generated by Spinach GUI "+SpinachGUIver+" \r\n";
		header+="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \r\n";
		header+="\r\n";
		header+="function "+Path::GetFileNameWithoutExtension(saveFileDialog->FileName)+"() \r\n";
		header+="\r\n";

		//Add this header to the final string
		final=header+final;

		//Convert and write to the file
		array<Byte>^ info = (gcnew UTF8Encoding( true ))->GetBytes(final);
		fs->Write( info, 0, info->Length  );
		fs->Close();
	};
}

#pragma endregion

/**
* @brief EventHandler for pressing key in cells in the 
* in General tab.
* @param sender The object that fire this event.
* @param e The event arguments for this event handler.
*/
System::Void SpinachGUI::Spinach::BasicSetextBoxKeyPress(System::Object^  sender, System::Windows::Forms::KeyPressEventArgs^  e) 
{
	basicsetnumstring="";
	internumstring="";

	//If key pressed is not number, or . or backspace, or E or enter do nothing
	if (!Char::IsNumber(e->KeyChar) && e->KeyChar != '.' && e->KeyChar != 'e' && 
		e->KeyChar != 'E' && e->KeyChar != '\b' && e->KeyChar !=(char)13)
	{
		e->Handled = true;
	}
	else
	{
		//When enter is hitted
		if (e->KeyChar ==(char)13)
		{
			double result;

			//Try to parse the number
			if(Double::TryParse(((TextBox^)sender)->Text, result))
			{
				//Returned to original color of the textbox
				((TextBox^)sender)->BackColor=System::Drawing::SystemColors::Window;

				//Write the magnetic field, proximityy cut-off and temperature in the appropriate format in the string
				magnetstring="sys.magnet="+ MagnettextBox->Text+";\r\n";

				//Update  the final strings
				WriteHeader();
				WriteFooter();
			}//else do nothing if not a valid number
			else e->Handled = true;

		}//When normal writing is happenning the Textbox color change to blue
		else ((TextBox^)sender)->BackColor=System::Drawing::SystemColors::Highlight;
	};
}

#pragma endregion

#pragma region Preview box

 /**
* @brief EventHandler for when we move the mouse with mouse button down, hand effect.
* Not perfect from times to times crash.
* @param sender The object that fire this event.
* @param e The event arguments for this event handler.
*/
System::Void SpinachGUI::Spinach::PreviewtextBox_MouseMove(System::Object^  sender, System::Windows::Forms::MouseEventArgs^  e) 
 {
	 //Only for left button
	 if( e->Button == System::Windows::Forms::MouseButtons::Left)
	 {
		 //for the X coordinate
		 int tempX=panel2->HorizontalScroll->Value+2*(InitialPoint->X-e->Location.X);

		 //The value of position should be inside the range of horizontal scroll
		 if(tempX>panel2->HorizontalScroll->Minimum && tempX<panel2->HorizontalScroll->Maximum)
		 {
			 //Set the value of the Horizontal scroll
			 panel2->HorizontalScroll->Value+=2*(InitialPoint->X-e->Location.X);

			 //Reset the initial point
			 InitialPoint->X=e->Location.X;
		 }

		 //for the Y coordinate
		 int tempY=panel2->VerticalScroll->Value+2*(InitialPoint->Y-e->Location.Y);

		 //The value of position should be inside the range of Vertical scroll
		 if(tempY>panel2->VerticalScroll->Minimum && tempY<panel2->VerticalScroll->Maximum)
		 {
			 //Set the value of the Vertical scroll
			 panel2->VerticalScroll->Value+=2*(InitialPoint->Y-e->Location.Y);

			 //Reset the initial point
			 InitialPoint->Y=e->Location.Y;
		 }
	 }
 }

 /**
* @brief EventHandler for when we press mouse button down to save initial position.
* @param sender The object that fire this event.
* @param e The event arguments for this event handler.
*/
System::Void SpinachGUI::Spinach::PreviewtextBox_MouseDown(System::Object^  sender, System::Windows::Forms::MouseEventArgs^  e) 
{
	//Save initial position and then fire mouseMove
	InitialPoint=e->Location;
	PreviewtextBox_MouseMove(sender,e);
}

#pragma endregion